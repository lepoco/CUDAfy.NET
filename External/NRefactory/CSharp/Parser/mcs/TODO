===========================================

* Value Parameter

	I believe that `Value Parameter' might have been introduced
	after C# 1.0, also notice than in the treatment of Value Parameter
	the parameters are defined in four categories:

	Section 9.3 in the latest spec.


Large project:
--------------

New
---

	It would be nice to optimize the case of:

		Method (new ValueType ())

	So that no temporary is created, and we only use a newobj call
	that remains on the stack, as opposed to ldloca, initobj, ldloc
	call.

NEW NOTES:
----------

	ImplicitStandardConversionExists and ImplicitStandardConversion
	should always be the same, but there are a few diverging lines that
	must be studied:

			if (expr_type == target_type && !(expr is NullLiteral))
				return expr;

	vs:

			if (expr_type == target_type)
				return true;

****************************************************************************************
* 
*   The information on the rest of this file is mostly outdated, and its kept here for
*   historical reasons
*
****************************************************************************************
 
Error Reporting:
----------------

	* Make yyerror show a nice syntax error, instead of the current mess.

Optimization ideas
------------------

	Currently when we build a type cache, it contains private members,
	internal members, and internal protected members;   We should trim
	these out, as it shows up on the profile.

	We create too many Arraylists;  When we know the size, we should create
	an array;

	During parsing we use arraylists to accumulate data, like this:

		thing:
		
		thing_list
			: thing { $$ =new ArrayList (); $$.Add ($1); }
			| thing_list thing { ArrayList a = $1; a.Add ($2); $$ = a; }

	We probably could start using "Pairs" there:

		thing_list
			: thing { $$ = new Pair ($1, null); }
			| thing_list thing { Pair p = $1; $$ = new Pair ($2, $1); }


EmitContext.ResolveTypeTree
---------------------------

	We should investigate its usage.  The problem is that by default
	this will be set when calling FindType, that triggers a more expensive
	lookup.

	I believe we should pass the current EmitContext (which has this turned off
	by default) to ResolveType/REsolveTypeExpr and then have the routines that
	need ResolveType to pass null as the emit context.

DeclareLocal audit
------------------

	DeclareLocal is used in various statements.  The audit should be done
	in two steps:

		* Identify all the declare locals.

		* Identify its uses.

		* Find if we can make wrapper functions for all of them.

	Then we can move DeclareLocal into a helper class.

	This is required to fix foreach in iterators.

Ideas:
------

	Instead of the hack that *knows* about System.Object not having any children classes,
	we should just make it simple for a probe to know that there is no need for it.

Dead Code Elimination bugs:
---------------------------

	I should also resolve all the children expressions in Switch, Fixed, Using.

Major tasks:
------------
	Properties and 17.6.3: Finish it.

readonly variables and ref/out
	
BUGS
----

* Break/Continue statements

	A finally block should reset the InLoop/LoopBegin/LoopEnd, as
	they are logically outside the scope of the loop.

* Break/continue part 2.

	They should transfer control to the finally block if inside a try/catch
	block.

*
> // CSC sets beforefieldinit
> class X {
>   // .cctor will be generated by compiler
>   public static readonly object O = new System.Object ();
>   public static void Main () {}
> }
> 

PENDING TASKS
-------------

* Merge test 89 and test-34

* Code cleanup

	The information when registering a method in InternalParameters
	is duplicated, you can always get the types from the InternalParameters

* Emit modreq for volatiles

	Handle modreq from public apis.

* Merge tree.cs, rootcontext.cs

OPTIMIZATIONS
-------------

* User Defined Conversions is doing way too many calls to do union sets that are not needed

* Add test case for destructors

* Places that use `Ldelema' are basically places where I will be
  initializing a value type.  I could apply an optimization to 
  disable the implicit local temporary from being created (by using
  the method in New).

* Dropping TypeContainer as an argument to EmitContext

 	My theory is that I can get rid of the TypeBuilder completely from
	the EmitContext, and have typecasts where it is used (from
	DeclSpace to where it matters).  

	The only pending problem is that the code that implements Aliases
	is on TypeContainer, and probably should go in DeclSpace.

* Tests

	Write tests for the various reference conversions.  We have
	test for all the numeric conversions.

* Optimizations: variable allocation.

	When local variables of a type are required, we should request
	the variable and later release it when we are done, so that
	the same local variable slot can be reused later on.

* Add a cache for the various GetArrayMethod operations.

* MakeUnionSet Callers

	If the types are the same, there is no need to compute the unionset,
 	we can just use the list from one of the types.

* Factor the lookup code for class declarations an interfaces
  (interface.cs:GetInterfaceByName)

RECOMMENDATIONS
---------------

* Use of lexer.Location in the parser

	Currently we do:

	TOKEN nt TERMINAL nt TERMINAL nt3 {
		$$ = new Blah ($2, $4, $6, lexer.Location);
	}

	This is bad, because the lexer.Location is for the last item in `nt3'

	We need to change that to use this pattern:

	TOKEN { oob_stack.Push (lexer.Location) } nt TERMINAL nt TERMINAL nt3 {
		$$ = new Blah ($3, $5, $7, (Location) oob_stack.Pop ());
	}

	Notice how numbering of the arguments changes as the
	{ oob_stack.Push (lexer.Location) } takes a "slot"  in the productions.

